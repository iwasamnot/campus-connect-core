/**
 * Serverless Vector RAG Engine - Data Ingestion Script
 * 
 * This script uploads university data to Pinecone with embeddings generated by Google Gemini.
 * 
 * Usage:
 *   node scripts/uploadToPinecone.js
 * 
 * Environment Variables Required:
 *   - PINECONE_API_KEY: Your Pinecone API key
 *   - PINECONE_INDEX_NAME: The name of your Pinecone index (default: campus-connect-index)
 *   - GEMINI_API_KEY: Your Google Gemini API key for generating embeddings
 */

import { Pinecone } from '@pinecone-database/pinecone';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { config } from 'dotenv';
import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Load environment variables
config();

// Get the directory name for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Configuration
const PINECONE_API_KEY = process.env.PINECONE_API_KEY;
const PINECONE_INDEX_NAME = process.env.PINECONE_INDEX_NAME || 'campus-connect-index';
const GEMINI_API_KEY = process.env.GEMINI_API_KEY || process.env.VITE_GEMINI_API_KEY;

// Embedding model configuration
const EMBEDDING_MODEL = 'text-embedding-004';
const EMBEDDING_DIMENSION = 768; // text-embedding-004 produces 768-dimensional vectors

/**
 * Validate required environment variables
 */
function validateEnvironment() {
  const errors = [];
  
  if (!PINECONE_API_KEY) {
    errors.push('PINECONE_API_KEY is not set');
  }
  
  if (!GEMINI_API_KEY) {
    errors.push('GEMINI_API_KEY (or VITE_GEMINI_API_KEY) is not set');
  }
  
  if (errors.length > 0) {
    console.error('‚ùå Environment validation failed:');
    errors.forEach(err => console.error(`   - ${err}`));
    console.error('\nPlease set the required environment variables in your .env file.');
    process.exit(1);
  }
  
  console.log('‚úÖ Environment variables validated');
}

/**
 * Load university data from JSON file
 */
function loadUniversityData() {
  const dataPath = join(__dirname, '..', 'src', 'data', 'universityData.json');
  
  try {
    const rawData = readFileSync(dataPath, 'utf-8');
    const data = JSON.parse(rawData);
    
    if (!Array.isArray(data) || data.length === 0) {
      throw new Error('Data file is empty or not an array');
    }
    
    console.log(`‚úÖ Loaded ${data.length} documents from universityData.json`);
    return data;
  } catch (error) {
    console.error(`‚ùå Failed to load data from ${dataPath}:`, error.message);
    process.exit(1);
  }
}

/**
 * Initialize Pinecone client
 */
async function initializePinecone() {
  try {
    const pinecone = new Pinecone({
      apiKey: PINECONE_API_KEY,
    });
    
    console.log('‚úÖ Pinecone client initialized');
    return pinecone;
  } catch (error) {
    console.error('‚ùå Failed to initialize Pinecone:', error.message);
    process.exit(1);
  }
}

/**
 * Initialize Google Generative AI client for embeddings
 */
function initializeGemini() {
  try {
    const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
    console.log('‚úÖ Google Generative AI client initialized');
    return genAI;
  } catch (error) {
    console.error('‚ùå Failed to initialize Google Generative AI:', error.message);
    process.exit(1);
  }
}

/**
 * Generate embedding for a single text using Gemini
 */
async function generateEmbedding(genAI, text) {
  try {
    const model = genAI.getGenerativeModel({ model: EMBEDDING_MODEL });
    
    const result = await model.embedContent(text);
    const embedding = result.embedding.values;
    
    if (!embedding || embedding.length === 0) {
      throw new Error('Empty embedding returned');
    }
    
    return embedding;
  } catch (error) {
    console.error(`‚ùå Error generating embedding: ${error.message}`);
    throw error;
  }
}

/**
 * Process documents and generate embeddings in batches
 */
async function processDocuments(genAI, documents, batchSize = 5) {
  const processedDocuments = [];
  const totalBatches = Math.ceil(documents.length / batchSize);
  
  console.log(`\nüìä Processing ${documents.length} documents in ${totalBatches} batches...`);
  
  for (let i = 0; i < documents.length; i += batchSize) {
    const batch = documents.slice(i, i + batchSize);
    const batchNumber = Math.floor(i / batchSize) + 1;
    
    console.log(`   Processing batch ${batchNumber}/${totalBatches}...`);
    
    for (const doc of batch) {
      try {
        // Combine title and text for better embedding context
        const textToEmbed = doc.title ? `${doc.title}: ${doc.text}` : doc.text;
        
        const embedding = await generateEmbedding(genAI, textToEmbed);
        
        processedDocuments.push({
          id: doc.id,
          values: embedding,
          metadata: {
            text: doc.text,
            title: doc.title || '',
            category: doc.category || '',
            source: 'universityData.json',
          },
        });
        
      } catch (error) {
        console.error(`   ‚ö†Ô∏è Failed to process document ${doc.id}: ${error.message}`);
        // Continue with other documents
      }
    }
    
    // Rate limiting: wait between batches to avoid API limits
    if (i + batchSize < documents.length) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
  
  console.log(`‚úÖ Successfully processed ${processedDocuments.length}/${documents.length} documents`);
  return processedDocuments;
}

/**
 * Check if index exists and create/recreate if necessary
 */
async function ensureIndexExists(pinecone) {
  try {
    const indexes = await pinecone.listIndexes();
    const existingIndex = indexes.indexes?.find(idx => idx.name === PINECONE_INDEX_NAME);
    
    if (existingIndex) {
      // Check if dimension matches
      const indexDimension = existingIndex.dimension;
      
      if (indexDimension === EMBEDDING_DIMENSION) {
        console.log(`‚úÖ Index "${PINECONE_INDEX_NAME}" exists with correct dimension (${EMBEDDING_DIMENSION})`);
        return;
      }
      
      // Dimension mismatch - need to delete and recreate
      console.log(`‚ö†Ô∏è Index "${PINECONE_INDEX_NAME}" has dimension ${indexDimension}, but we need ${EMBEDDING_DIMENSION}`);
      console.log(`üóëÔ∏è Deleting existing index...`);
      
      await pinecone.deleteIndex(PINECONE_INDEX_NAME);
      console.log(`   Index deleted. Waiting before recreation...`);
      await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
    }
    
    console.log(`üìù Creating index "${PINECONE_INDEX_NAME}" with dimension ${EMBEDDING_DIMENSION}...`);
    
    await pinecone.createIndex({
      name: PINECONE_INDEX_NAME,
      dimension: EMBEDDING_DIMENSION,
      metric: 'cosine',
      spec: {
        serverless: {
          cloud: 'aws',
          region: 'us-east-1',
        },
      },
    });
    
    // Wait for index to be ready
    console.log('   Waiting for index to be ready...');
    let ready = false;
    let attempts = 0;
    const maxAttempts = 30; // 30 attempts x 2 seconds = 60 seconds max
    
    while (!ready && attempts < maxAttempts) {
      await new Promise(resolve => setTimeout(resolve, 2000));
      attempts++;
      
      try {
        const indexList = await pinecone.listIndexes();
        const idx = indexList.indexes?.find(i => i.name === PINECONE_INDEX_NAME);
        if (idx && idx.status?.ready) {
          ready = true;
        }
      } catch (e) {
        // Index might not be queryable yet
      }
      
      if (attempts % 5 === 0) {
        console.log(`   Still waiting... (${attempts * 2}s)`);
      }
    }
    
    console.log(`‚úÖ Index "${PINECONE_INDEX_NAME}" created successfully with dimension ${EMBEDDING_DIMENSION}`);
  } catch (error) {
    if (error.message?.includes('already exists')) {
      console.log(`‚úÖ Index "${PINECONE_INDEX_NAME}" already exists`);
      return;
    }
    console.error('‚ùå Error ensuring index exists:', error.message);
    throw error;
  }
}

/**
 * Upsert vectors to Pinecone in batches
 */
async function upsertToPinecone(pinecone, vectors, batchSize = 100) {
  const index = pinecone.index(PINECONE_INDEX_NAME);
  const totalBatches = Math.ceil(vectors.length / batchSize);
  
  console.log(`\nüì§ Upserting ${vectors.length} vectors to Pinecone in ${totalBatches} batches...`);
  
  let totalUpserted = 0;
  
  for (let i = 0; i < vectors.length; i += batchSize) {
    const batch = vectors.slice(i, i + batchSize);
    const batchNumber = Math.floor(i / batchSize) + 1;
    
    try {
      await index.upsert(batch);
      totalUpserted += batch.length;
      console.log(`   Batch ${batchNumber}/${totalBatches}: Upserted ${batch.length} vectors`);
    } catch (error) {
      console.error(`   ‚ùå Batch ${batchNumber} failed: ${error.message}`);
    }
    
    // Small delay between batches
    if (i + batchSize < vectors.length) {
      await new Promise(resolve => setTimeout(resolve, 500));
    }
  }
  
  console.log(`‚úÖ Total upserted: ${totalUpserted} vectors`);
  return totalUpserted;
}

/**
 * Verify the upload by querying the index
 */
async function verifyUpload(pinecone, genAI) {
  console.log('\nüîç Verifying upload...');
  
  try {
    const index = pinecone.index(PINECONE_INDEX_NAME);
    
    // Get index stats
    const stats = await index.describeIndexStats();
    console.log(`   Total vectors in index: ${stats.totalRecordCount || 0}`);
    
    // Test query
    const testQuery = 'What courses does SISTC offer?';
    const queryEmbedding = await generateEmbedding(genAI, testQuery);
    
    const results = await index.query({
      vector: queryEmbedding,
      topK: 3,
      includeMetadata: true,
    });
    
    console.log(`\nüìã Test Query: "${testQuery}"`);
    console.log('   Top 3 matches:');
    
    results.matches?.forEach((match, idx) => {
      const title = match.metadata?.title || 'Untitled';
      const score = (match.score * 100).toFixed(1);
      console.log(`   ${idx + 1}. [${score}%] ${title}`);
    });
    
    console.log('\n‚úÖ Verification complete!');
  } catch (error) {
    console.error('‚ö†Ô∏è Verification failed:', error.message);
  }
}

/**
 * Main execution function
 */
async function main() {
  console.log('üöÄ Serverless Vector RAG Engine - Data Ingestion');
  console.log('================================================\n');
  
  // Validate environment
  validateEnvironment();
  
  // Load data
  const documents = loadUniversityData();
  
  // Initialize clients
  const pinecone = await initializePinecone();
  const genAI = initializeGemini();
  
  // Ensure index exists
  await ensureIndexExists(pinecone);
  
  // Process documents and generate embeddings
  const vectors = await processDocuments(genAI, documents);
  
  if (vectors.length === 0) {
    console.error('‚ùå No vectors to upsert. Exiting.');
    process.exit(1);
  }
  
  // Upsert to Pinecone
  await upsertToPinecone(pinecone, vectors);
  
  // Verify the upload
  await verifyUpload(pinecone, genAI);
  
  console.log('\nüéâ Data ingestion complete!');
  console.log(`   Index: ${PINECONE_INDEX_NAME}`);
  console.log(`   Vectors: ${vectors.length}`);
}

// Run the script
main().catch(error => {
  console.error('\n‚ùå Fatal error:', error);
  process.exit(1);
});
